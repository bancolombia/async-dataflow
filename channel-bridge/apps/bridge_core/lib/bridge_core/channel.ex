defmodule BridgeCore.Channel do
  @moduledoc """
  Abstraction for an async-dataflow-channel-sender's channel
  """

  alias BridgeCore.{AppClient, CloudEvent, User}

  alias AdfSenderConnector.Message

  require Logger

  @type channel_alias() :: binary()
  @type application_ref() :: AppClient.t()
  @type channel_key() :: binary()
  @type channel_ref() :: binary()
  @type procs() :: list()
  @type user_ref() :: User.t()
  @type channel_secret() :: binary()
  @type datetime() :: DateTime.t()

  @type t() :: %__MODULE__{
    application_ref: application_ref(),
    channel_alias: channel_alias(),
    created_at: datetime(),
    procs: procs(),
    reason: term(),
    status: atom(),
    updated_at: datetime() | nil,
    user_ref: user_ref(),
    last_message_at: datetime() | nil
  }

  defstruct application_ref: nil,
    channel_alias: nil,
    created_at: nil,
    procs: nil,
    reason: nil,
    status: nil,
    updated_at: nil,
    user_ref: nil,
    last_message_at: nil

  @doc """
  creates a simple channel representation
  """
  @spec new(channel_alias(), application_ref(), user_ref()) :: t()
  def new(channel_alias, application_ref, user_ref) do
    %__MODULE__{
      application_ref: application_ref,
      channel_alias: channel_alias,
      created_at: DateTime.utc_now(),
      procs: [],
      reason: nil,
      status: :new,
      updated_at: nil,
      user_ref: user_ref,
      last_message_at: nil
    }
  end

  @doc """
  register credentials info provided by ADF Channel Sender
  """
  @spec update_credentials(t(), binary(), binary()) :: t()
  def update_credentials(channel, channel_ref, channel_secret) do
    %__MODULE__{
      channel
      | procs: [BridgeCore.Reference.new(channel_ref, channel_secret) | channel.procs],
        # internally this is considered 'channel ready' to route messages
        status: :ready,
        updated_at: DateTime.utc_now()
    }
  end

#  @doc """
#  Adds a list of refs to the channel ref list. A ref is a channel_ref id generated by ADF Channel Sender.
#  """
#  @spec add_procs(t(), procs()) :: t()
#  def add_procs(channel, procs) do
#    new_procs = Enum.dedup(procs ++ channel.procs)
#    %__MODULE__{channel | procs: new_procs, updated_at: DateTime.utc_now()}
#  end

#  @doc """
#  Updates the status and reason of the channel.
#  """
#  @spec set_status(t(), term(), term()) :: t()
#  def set_status(channel, status, reason) do
#    %__MODULE__{channel | status: status, reason: reason, updated_at: DateTime.utc_now()}
#  end

  @doc """
  Updates the last message routed timestamp to the current time.
  """
  @spec update_last_message(t()) :: t()
  def update_last_message(channel) do
    %__MODULE__{channel | last_message_at: DateTime.utc_now()}
  end

  @doc """
  Obtains the ADF Channel Sender client Message struct to be routed.
  """
  @spec prepare_messages(t(), CloudEvent.t()) :: {:ok, any()} | {:error, term()}
  def prepare_messages(channel, cloud_event) do

    with {:ok, ch_procs} <- get_procs(channel),
         {:ok, _ } <- check_cloud_event(cloud_event) do

      {:ok,
        Stream.map(ch_procs, fn proc ->
          {proc.channel_ref, cloud_event.id, Map.from_struct(cloud_event), cloud_event.type}
        end) |>
        Stream.map(fn {ref, evt_id, data, name} ->
          Message.new(ref, evt_id, evt_id, data, name)
        end)
      }

    else
      {:error, :empty_refs} = err ->
        Logger.error("channel_ref is empty or unknown. #{inspect(cloud_event)}")
        err

      {:error, :invalid_message} = err ->
        Logger.error("Invalid cloud_event. #{inspect(cloud_event)}")
        err
    end
  end

  def get_procs(channel) do
    case channel.procs do
      nil ->
        {:error, :empty_refs}
      [] ->
        {:error, :empty_refs}
      _ ->
        {:ok, channel.procs}
    end
  end

  defp check_cloud_event(cloud_event) do
    case cloud_event do
      nil ->
        {:error, :invalid_message}
      _ ->
        {:ok, cloud_event}
    end
  end

  @doc """
  Checks if the state of the channel has reached the inactivity timeout. Only applies when state is :ready (open).
  """
  @spec check_state_inactivity(t()) :: :noop | :timeout
  def check_state_inactivity(channel) do
    case channel.status do
      :ready ->
        last_msg = case channel.last_message_at do
          nil -> channel.updated_at
          _ -> channel.last_message_at
        end
        if DateTime.diff(DateTime.utc_now(), last_msg) > channel.application_ref.channel_timeout do
          Logger.warning("Channel inactivity timeout reached: #{inspect(channel)}")
          :timeout
        else
          :noop
        end
      _ ->
        :noop
    end
  end

  @doc """
  Changes the channel current state to closed, no further operations can be done with this channel.
  ADF Channel Sender it's not notified of this action. Note that ADF Channel Sender handles channel closing
  via timeouts or socket disconnection.
  """
  @spec close(t()) :: {:ok, t()} | {:error, reason :: term}
  def close(channel) do
    case channel.status do
      :closed ->
        {:ok, channel}

      _ ->
        {:ok,
         %__MODULE__{
           channel
           | procs: [],
             status: :closed,
             updated_at: DateTime.utc_now()
         }}
    end
  end

end
